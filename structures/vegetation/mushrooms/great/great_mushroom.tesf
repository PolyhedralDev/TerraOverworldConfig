num randPrecision = 100;
num goldenAngle = 2.39996;
num pi = 3.14159;

str logBlockX = "minecraft:mushroom_stem";
str logBlockY = "minecraft:mushroom_stem";
str logBlockZ = "minecraft:mushroom_stem";

num trunkHeight = 12;
num trunkRadius = 4;
num trunkBranches = 1;
num trunkBranchLength = trunkHeight * 0.2;
num trunkBranchLengthVariation = 10;
num trunkBranchRadius = 3;
num trunkBranchVerticalDirection = 4;
num trunkSideBranches = 0;
num trunkSideBranchMinHeight = 100;

num curveStrength = 30;
num curveStrengthVariation = 0;
num curveMid = 0.5;

num endBranches = 1;
num endBranchMinHeight = 100;
num endTrunkBranchVerticalDirection = 1;
num endBranchInterval = 3;
num endBranchVerticalDirection = 0.1;

num warp = 10;
num stemHeight = 21 + randomInt(4);
num stemStartRadius = 1 + stemHeight / 15;
num stemEndRadius = 1.2;
num stemCollarThreshold = 1 - randomInt(randPrecision) / randPrecision / 2;
num stemCollarThickness = 3;
num diskMinHeight = 4;
num diskMaxHeight = stemHeight - 4;
num diskInterval = 3 + randomInt(3);
bool addDisks = false;
if (randomInt(2) == 0) addDisks = true;

num capRadius = stemHeight / 1.5;
num innerCapRadius = capRadius - 3;
num midCapRadius = capRadius - 2;
num warpCapTop = 0.5;
num warpCapTopFrequency = 2;
num capSquish = 1 - randomInt(randPrecision) / randPrecision * 0.5;
num capRadiusHorizontal = round(capRadius + capRadius * warpCapTop);
num yTranslateCap = 2;

str outerBlock = "minecraft:red_mushroom_block";
str innerBlock = "minecraft:red_mushroom_block[up=false,down=false,north=false,east=false,south=false,west=false]";
str spotBlock = "minecraft:shroomlight";
str diskStructure = "red_mushroom_disk";

if (randomInt(2) == 0) {
    capSquish = 2;
    innerCapRadius = capRadius - 4;
    midCapRadius = capRadius - 2;
    outerBlock = "minecraft:brown_mushroom_block";
    innerBlock = "minecraft:brown_mushroom_block[up=false,down=false,north=false,east=false,south=false,west=false]";
    spotBlock = "minecraft:shroomlight";
    diskStructure = "brown_mushroom_disk";
}

num trunkBranchAngle = randomInt(randPrecision) / randPrecision * 2 * pi;
num trunkBranchInterval = round((trunkHeight - trunkSideBranchMinHeight) / trunkSideBranches);
num currentTrunkLevelBranches = 1; // Only generate 1 branch at a time when placing in the middle of the trunk
bool reachedTrunkTop = false;
for (num trunkLevel = -3; trunkLevel <= trunkHeight; trunkLevel = trunkLevel + 1) {

    if (trunkLevel == trunkHeight) {
        reachedTrunkTop = true;
        currentTrunkLevelBranches = trunkBranches; // If the top is reached, multiple branches can generate
    }

    // Determine if a branch should be placed at the current layer of the trunk
    if ((trunkLevel >= trunkSideBranchMinHeight && (trunkLevel - trunkSideBranchMinHeight) % trunkBranchInterval == 0) || reachedTrunkTop) {

        for (num trunkBranch = 0; trunkBranch < currentTrunkLevelBranches; trunkBranch = trunkBranch + 1) {

            // Trunk branch generation
            num dx = sin(trunkBranchAngle) * (1 - trunkBranch / currentTrunkLevelBranches);
            num dy = trunkBranchVerticalDirection;
            num dz = cos(trunkBranchAngle) * (1 - trunkBranch / currentTrunkLevelBranches);
            num mag = sqrt(pow2(dx) + pow2(dy) + pow2(dz));
            dx = dx / mag;
            dy = dy / mag;
            dz = dz / mag;

            num px = 0;
            num py = trunkLevel;
            num pz = 0;

            num currentEndBranches = 1; // How many end branches to generate at each interval
            bool reachedTrunkBranchEnd = false;
            num endTrunkBranchAngle = randomInt(randPrecision) / randPrecision * 2 * pi;
            num currentCurveStrength = (curveStrength + randomInt(randPrecision) / randPrecision * curveStrengthVariation) * (1 - trunkBranch / currentTrunkLevelBranches);
            num branchLength = trunkBranchLength + round(randomInt(randPrecision) / randPrecision * trunkBranchLengthVariation);
            // ^ Should be an integer so the script can check discrete values.

            for (num l = 0; l <= branchLength; l = l + 1) {

                if (l == branchLength) {
                    reachedTrunkBranchEnd = true;
                    currentEndBranches = endBranches;
                }

                if ((l % endBranchInterval == 0 && l > endBranchMinHeight) || reachedTrunkBranchEnd) {
                    for (num endBranch = 0; endBranch < currentEndBranches; endBranch = endBranch + 1) {
                        // Local endBranch direction vector
                        num cdx = sin(endTrunkBranchAngle);
                        num cdy = endTrunkBranchVerticalDirection;
                        num cdz = cos(endTrunkBranchAngle);

                        // Transform endBranch local vector to be relative to constructed coordinate space of trunkBranch vector
                        cdx = -dy * cdx + dx * cdy + dx * cdz;
                        cdy = dx * cdx + dy * cdy + dz * cdz;
                        cdz = dz * cdx + dz * cdy + -dy * cdz;

                        // Point vector up towards y axis
                        cdy = cdy + endBranchVerticalDirection;

                        // Normalize vector
                        num cmag = sqrt(pow2(cdx) + pow2(cdy) + pow2(cdz));
                        cdx = cdx / cmag;
                        cdy = cdy / cmag;
                        cdz = cdz / cmag;

                        str endBranchBlock = logBlockY;
                        if (abs(cdx) > max(abs(cdy), abs(cdz))) endBranchBlock = logBlockX;
                        else if (abs(cdz) > max(abs(cdy), abs(cdx))) endBranchBlock = logBlockZ;


                    }
                }

                str trunkBranchBlock = logBlockY;
                if (abs(dx) > max(abs(dy), abs(dz))) trunkBranchBlock = logBlockX;
                else if (abs(dz) > max(abs(dy), abs(dx))) trunkBranchBlock = logBlockZ;

                num trunkBranchT = l / branchLength;
                num trunkBranchTInverse = 1 - trunkBranchT;
                num radius = trunkBranchT + trunkBranchTInverse * trunkBranchRadius;
                num radiusSquared = pow2(radius);

                for (num x = floor(-radius); x < ceil(radius); x = x + 1) {
                    for (num y = floor(-radius); y < ceil(radius); y = y + 1) {
                        for (num z = floor(-radius); z < ceil(radius); z = z + 1) {
                            num distanceSquared = pow2(x) + pow2(y) + pow2(z);
                            if (distanceSquared < radiusSquared) {
                                block(px + x, py + y, pz + z, trunkBranchBlock, false);
                            }
                        }
                    }
                }

                // Adjust y component according to curve function
                num dyv = currentCurveStrength * pow2(trunkBranchT) * (trunkBranchT - curveMid) * pow2(trunkBranchT - 1);
                dy = dy + dyv;

                // Normalize vector
                mag = sqrt(pow2(dx) + pow2(dy) + pow2(dz));
                dx = dx / mag;
                dy = dy / mag;
                dz = dz / mag;

                // Move to next point by 1 unit
                px = px + dx;
                py = py + dy;
                pz = pz + dz;
            }

            num t = 0;
            num it = 1;
            num currentRadius = stemStartRadius;
            num currentRadiusSquared = pow2(currentRadius);
            num distanceSquared = 0;
            for (num h = -2; h < stemHeight; h = h + 1) {
                if (addDisks && h > diskMinHeight && h < diskMaxHeight && h % diskInterval == 0) {
                    num ox = sampler("simplex", h, originX()) * warp * t;
                    num oz = sampler("simplex", h, originZ()) * warp * t;
                    structure(px + ox, py + h, pz + oz, diskStructure, "NONE");
                }

                t = h / stemHeight;
                it = 1 - t;
                currentRadius = stemStartRadius * it + stemEndRadius * t;
                if (t > stemCollarThreshold) currentRadius = currentRadius + stemCollarThickness * it;
                currentRadiusSquared = pow2(currentRadius);
                for (num x = round(-currentRadius); x < round(currentRadius); x = x + 1) {
                    for (num z = round(-currentRadius); z < round(currentRadius); z = z + 1) {
                        distanceSquared = pow2(x) + pow2(z);
                        if (distanceSquared < currentRadiusSquared) {
                            num warpX = sampler("simplex", h, originX()) * warp * t;
                            num warpZ = sampler("simplex", h, originZ()) * warp * t;
                            block(px + x + warpX, py + h, pz + z + warpZ, "minecraft:mushroom_stem");
                        }
                    }
                }
            }

            num radiusSquared = pow2(capRadius);
            num innerRadiusSquared = pow2(innerCapRadius);
            num midRadiusSquared = pow2(midCapRadius);

            num ox = sampler("simplex", stemHeight, originX()) * warp;
            num oy = stemHeight - capRadius / capSquish;
            num oz = sampler("simplex", stemHeight, originZ()) * warp;

            for (num x = -capRadiusHorizontal; x < capRadiusHorizontal; x = x + 1) {
                for (num y = 0; y < capRadius / capSquish; y = y + 1) {
                    for (num z = -capRadiusHorizontal; z < capRadiusHorizontal; z = z + 1) {
                        num warpX = sampler("simplex", warpCapTopFrequency * (originX() + ox + x), warpCapTopFrequency * (originZ() + oz + z)) * abs(y - midCapRadius) * warpCapTop;
                        num warpZ = sampler("simplex", warpCapTopFrequency * (originZ() + ox + x + 1000), warpCapTopFrequency * (originZ() + oz + z)) * abs(y - midCapRadius) * warpCapTop;
                        distanceSquared = pow2(x + warpX) + pow2(y * capSquish) + pow2(z + warpZ);
                        if (distanceSquared < radiusSquared && distanceSquared > innerRadiusSquared && y + 1 >= abs(warpX + warpZ)) {
                            if (distanceSquared > midRadiusSquared) {
                                if (randomInt(40) == 0) {
                                    block(px+ x, oy + py + y + yTranslateCap, pz + z, spotBlock);
                                } else {
                                    block(px + x, oy + py  + y + yTranslateCap, pz  + z, outerBlock);
                                }
                            } else {
                                block(px + x, oy + py + y + yTranslateCap, pz  + z, innerBlock);
                            }
                        }
                    }
                }
            }

            trunkBranchAngle = trunkBranchAngle + goldenAngle;
        }
    }

    // Main trunk block placement

    num trunkT = trunkLevel / trunkHeight;
    num trunkTInverse = 1 - trunkT;
    num trunkLevelRadius = trunkRadius * trunkTInverse + trunkBranchRadius * trunkT;
    num trunkLevelRadiusSquared = pow2(trunkLevelRadius);
    num trunkLevelRadiusInner = trunkLevelRadius - 1.5;
    num trunkLevelRadiusInnerSquared = pow2(trunkLevelRadiusInner);

    for (num x = round(-trunkLevelRadius); x < round(trunkLevelRadius); x = x + 1) {
        for (num z = round(-trunkLevelRadius); z < round(trunkLevelRadius); z = z + 1) {
            num distanceSquared = pow2(x) + pow2(z);
            if (distanceSquared < trunkLevelRadiusSquared) {
                if (distanceSquared < trunkLevelRadiusInnerSquared) {
                    block(x, trunkLevel, z, "minecraft:air");
                    block(x, max(0, trunkLevel - 1), z, "minecraft:air"); // Sometimes trunk branches place blocks below so this should remove them
                } else {
                    str trunkBlock = logBlockY;
                    block(x, trunkLevel, z, trunkBlock);
                }
            }
        }
    }
}
