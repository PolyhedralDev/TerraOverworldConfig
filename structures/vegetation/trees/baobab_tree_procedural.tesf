num randPrecision = 100;
num goldenAngle = 2.39996;
num pi = 3.14159;

str trunkBlock = "minecraft:acacia_log";
str trunkEdgeBlock = "minecraft:acacia_wood";
str rootBlockX = "minecraft:acacia_wood";
str rootBlockZ = "minecraft:acacia_wood";

num trunkRadius = 1.75;
num trunkHeight = 10 + randomInt(10);
num offset = 0.1;

num topBranchYOffsetVariation = 2;
num topBranchHorizontalLengthMin = 1;
num topBranchHorizontalLengthVariation = 1.5;
num topBranchVerticalLengthMin = 2;
num topBranchVerticalLengthVariation = 2;
num topBranchLeafRadiusMin = 3.5;
num topBranchLeafTranslate = 0;
num topBranchLeafTopFlatness = 3;
num topBranchLeafBottomFlatness = 4;
num topBranchLeafDensity = 1;
str topBranchLeafStructure = "acacia_leaves_clump";
str topBranchBlockX = "minecraft:acacia_log[axis=x]";
str topBranchBlockY = "minecraft:acacia_log[axis=y]";
str topBranchBlockZ = "minecraft:acacia_log[axis=z]";

num sideBranchChance = 3;
num sideBranchInterval = 2;
num sideBranchMinHeight = 7 + randomInt(2);
num sideBranchMaxHeight = trunkHeight - 5;
num sideBranchYOffsetVariation = 3;
num sideBranchHorizontalLengthMin = 2.5;
num sideBranchHorizontalLengthVariation = 1;
num sideBranchVerticalLengthMin = 1.5;
num sideBranchVerticalLengthVariation = 2;
num sideBranchLeafRadiusMin = 3.5;
num sideBranchLeafTranslate = 0;
num sideBranchLeafTopFlatness = 3;
num sideBranchLeafBottomFlatness = 4;
num sideBranchLeafDensity = 1;
str sideBranchLeafStructure = "acacia_leaves_clump";
str sideBranchBlockX = "minecraft:acacia_log[axis=x]";
str sideBranchBlockY = "minecraft:acacia_log[axis=y]";
str sideBranchBlockZ = "minecraft:acacia_log[axis=z]";

if (getBlock(3, -2, 0) == "minecraft:air") fail;
if (getBlock(-3, -2, 0) == "minecraft:air") fail;
if (getBlock(0, -2, 3) == "minecraft:air") fail;
if (getBlock(0, -2, -3) == "minecraft:air") fail;

num branchAngle = randomInt(randPrecision) / randPrecision * 2 * pi;

// Generate roots at base of trunk
num roots = 5;
num rootMaxDepth = 3;
num rootHeight = 6;
num rootLength = 4;
num rootAngle = randomInt(randPrecision) / randPrecision * 2 * pi;
for (num r = 0; r < roots; r = r + 1) {
    num dx = sin(rootAngle);
    num dz = cos(rootAngle);
    str rootBlock = rootBlockX;
    if (abs(dz) > abs(dx)) rootBlock = rootBlockZ;
    for (num l = 0; l <= rootLength; l = l + 1) {
        num height = rootHeight * (1 - (l / rootLength));
        bool bottomedOut = false;
        for (num h = height; h >= -rootMaxDepth; h = h - 1) {
            if (check(round(l * dx), round(h), round(l * dz)) != "AIR") {
                bottomedOut = true;
                break;
            }
            block(l * dx, h, l * dz, rootBlock);
        }
        if (!bottomedOut) break;
    }
    rootAngle = rootAngle + goldenAngle;
}

// tree trunk
for (num h = 0; h < trunkHeight; h = h + 1) {

    // Reduce radius inversely to height
    num r = trunkRadius;

    if (h == trunkHeight - 1) trunkBlock = trunkEdgeBlock;

    // Generate sphere at each point
    for (num x = -r; x < r; x = x + 1) {
        for (num z = -r; z < r; z = z + 1) {
            if (pow(x + offset, 2) + pow(z + offset, 2) < pow(r + offset, 2)) {
                block(x, h, z, trunkBlock, true);
            }
        }
    }

    if (h > sideBranchMinHeight && h < sideBranchMaxHeight) {
        if (h % sideBranchInterval == 0) {

            // chance for no branch
            if (randomInt(sideBranchChance) == 0) continue;

            // Branch origin
            num ox = 0;
            num oy = h - randomInt(sideBranchYOffsetVariation);
            num oz = 0;
            // Direction and Offset for each side branch generation for each loop run
            num xDir = 0;
            num zDir = 0;
            num random = randomInt(4);
            if (random == 0) {
                xDir = 1;
                ox = ox + (1 + randomInt(2));
                oz = oz + (1 - randomInt(3));
            } else if (random == 1) {
                xDir = -1;
                ox = ox - (1 + randomInt(2));
                oz = oz + (1 - randomInt(3));
            } else if (random == 2) {
                zDir = 1;
                oz = oz + (1 + randomInt(2));
                ox = ox + (1 - randomInt(3));
            } else if (random == 3) {
                zDir = -1;
                oz = oz - (1 + randomInt(2));
                ox = ox + (1 - randomInt(3));
            }

            str branchBlock = sideBranchBlockY;
            // Set branch block based on direction
            if (xDir != 0) branchBlock = sideBranchBlockX;
            if (zDir != 0) branchBlock = sideBranchBlockZ;

            // place trunk edge for branch start
            block(ox + (-1 * xDir), oy, oz + (-1 * zDir), trunkEdgeBlock, true);

            num horizontalBranchLength = sideBranchHorizontalLengthMin + randomInt(randPrecision) / randPrecision * sideBranchHorizontalLengthVariation;
            block(ox * xDir - 1, oy, oz * zDir - 1, trunkEdgeBlock, true);
            // Generate horizontal branch portion
            for (num l = 0; l <= horizontalBranchLength; l = l + 1) {
                block(ox + (l * xDir), oy, oz + (l * zDir), branchBlock, true);
            }

            num verticalBranchLength = sideBranchVerticalLengthMin + randomInt(randPrecision) / randPrecision * sideBranchVerticalLengthVariation;
            branchBlock = sideBranchBlockY;

            ox = ox + (horizontalBranchLength * xDir);
            oz = oz + (horizontalBranchLength * zDir);

            // Generate vertical branch portion
            for (num vl = 0; vl <= verticalBranchLength; vl = vl + 1) {
                block(ox, oy + vl, oz, branchBlock, true);
            }

            // place trunk edge on corner
            block(ox, oy, oz, trunkEdgeBlock);

            // Rotate angle of next branch
            branchAngle = branchAngle + goldenAngle;
            // Generate leaf cluster at the end of the branch
            num radius = sideBranchLeafRadiusMin;
            num radiusSquared = pow(radius, 2);
            // Leaf cluster origin (end of branch)
            num lox = ox;
            num loy = oy + verticalBranchLength + sideBranchLeafTranslate;
            num loz = oz;
            for (num cx = ceil(-radius); cx <= ceil(radius); cx = cx + 1) {
                for (num cy = ceil(-radius / sideBranchLeafBottomFlatness); cy <= ceil(radius / sideBranchLeafTopFlatness); cy = cy + 1) {
                    for (num cz = ceil(-radius); cz <= ceil(radius); cz = cz + 1) {
                        num squashFactor = sideBranchLeafBottomFlatness;
                        if (cy > 0) squashFactor = sideBranchLeafTopFlatness;
                        num distanceSquared = pow(cx, 2) + pow(cy * squashFactor, 2) + pow(cz, 2);
                        if (distanceSquared < radiusSquared && randomInt(randPrecision) / randPrecision < sideBranchLeafDensity) {
                            structure(lox + cx, loy + cy, loz + cz, sideBranchLeafStructure, "NONE", "CW_90", "CCW_90", "CW_180");
                        }
                    }
                }
            }

        }
    }
}


for (num sb = 0; sb < 4; sb = sb + 1) {

    // Branch origin
    num ox = 0;
    num oy = (trunkHeight - 1) - randomInt(topBranchYOffsetVariation);
    num oz = 0;
    // Direction and Offset for each side branch generation for each loop run
    num xDir = 0;
    num zDir = 0;
    if (sb == 0) {
        xDir = 1;
        ox = ox + (1 + randomInt(2));
        oz = oz + (1 - randomInt(3));
    } else if (sb == 1) {
        xDir = -1;
        ox = ox - (1 + randomInt(2));
        oz = oz + (1 - randomInt(3));
    } else if (sb == 2) {
        zDir = 1;
        oz = oz + (1 + randomInt(2));
        ox = ox + (1 - randomInt(3));
    } else if (sb == 3) {
        zDir = -1;
        oz = oz - (1 + randomInt(2));
        ox = ox + (1 - randomInt(3));
    }

    str branchBlock = topBranchBlockY;
    // Set branch block based on direction
    if (xDir != 0) branchBlock = topBranchBlockX;
    if (zDir != 0) branchBlock = topBranchBlockZ;

    // place trunk edge for branch start
    block(ox + (-1 * xDir), oy, oz + (-1 * zDir), trunkEdgeBlock, true);

    num horizontalBranchLength = topBranchHorizontalLengthMin + randomInt(randPrecision) / randPrecision * topBranchHorizontalLengthVariation;
    block(ox * xDir - 1, oy, oz * zDir - 1, trunkEdgeBlock, true);
    // Generate horizontal branch portion
    for (num l = 0; l <= horizontalBranchLength; l = l + 1) {
        block(ox + (l * xDir), oy, oz + (l * zDir), branchBlock, true);
    }

    num verticalBranchLength = topBranchVerticalLengthMin + randomInt(randPrecision) / randPrecision * topBranchVerticalLengthVariation;
    branchBlock = topBranchBlockY;

    ox = ox + (horizontalBranchLength * xDir);
    oz = oz + (horizontalBranchLength * zDir);

    // Generate vertical branch portion
    for (num vl = 0; vl <= verticalBranchLength; vl = vl + 1) {
        block(ox, oy + vl, oz, branchBlock, true);
    }

    // place trunk edge on corner
    block(ox, oy, oz, trunkEdgeBlock);

    // Rotate angle of next branch
    branchAngle = branchAngle + goldenAngle;
    // Generate leaf cluster at the end of the branch
    num radius = topBranchLeafRadiusMin;
    num radiusSquared = pow(radius, 2);
    // Leaf cluster origin (end of branch)
    num lox = ox;
    num loy = oy + verticalBranchLength + topBranchLeafTranslate;
    num loz = oz;
    for (num cx = ceil(-radius); cx <= ceil(radius); cx = cx + 1) {
        for (num cy = ceil(-radius / topBranchLeafBottomFlatness); cy <= ceil(radius / topBranchLeafTopFlatness); cy = cy + 1) {
            for (num cz = ceil(-radius); cz <= ceil(radius); cz = cz + 1) {
                num squashFactor = topBranchLeafBottomFlatness;
                if (cy > 0) squashFactor = topBranchLeafTopFlatness;
                num distanceSquared = pow(cx, 2) + pow(cy * squashFactor, 2) + pow(cz, 2);
                if (distanceSquared < radiusSquared && randomInt(randPrecision) / randPrecision < topBranchLeafDensity) {
                    structure(lox + cx, loy + cy, loz + cz, topBranchLeafStructure, "NONE", "CW_90", "CCW_90", "CW_180");
                }
            }
        }
    }
}
